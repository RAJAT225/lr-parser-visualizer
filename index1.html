<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LR Parser Visualizer</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prop-types/15.8.1/prop-types.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.2/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          animation: {
            'fade-in': 'fadeIn 0.5s ease-in-out',
            'slide-up': 'slideUp 0.3s ease-out',
            'pulse-slow': 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite'
          },
          keyframes: {
            fadeIn: {
              '0%': { opacity: '0' },
              '100%': { opacity: '1' }
            },
            slideUp: {
              '0%': { transform: 'translateY(10px)', opacity: '0' },
              '100%': { transform: 'translateY(0)', opacity: '1' }
            }
          }
        }
      }
    }
  </script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/pyodide/v0.23.4/full/pyodide.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect } = React;

    function App() {
      const [grammar, setGrammar] = useState('S -> C C\nC -> c C | d');
      const [parserType, setParserType] = useState('CLR');
      const [inputString, setInputString] = useState('c c d d');
      const [canonicalOutput, setCanonicalOutput] = useState('');
      const [tableData, setTableData] = useState([]);
      const [parseOutput, setParseOutput] = useState('');
      const [parseTableData, setParseTableData] = useState([]);
      const [pyodide, setPyodide] = useState(null);
      const [isLoading, setIsLoading] = useState(false);
      const [error, setError] = useState(null);

      useEffect(() => {
        async function loadPyodideAndRun() {
          setIsLoading(true);
          try {
            const pyodideInstance = await loadPyodide();
            await pyodideInstance.loadPackage("micropip");
            setPyodide(pyodideInstance);
            console.log("Pyodide loaded successfully");
          } catch (error) {
            console.error("Error loading Pyodide:", error);
            setError(`Error loading Pyodide: ${error.message}`);
            setCanonicalOutput(`Error: Failed to load Pyodide`);
            setTableData([{ State: "0", error: `Failed to load Pyodide: ${error.message}` }]);
            setParseOutput(`Error: Failed to load Pyodide`);
          } finally {
            setIsLoading(false);
          }
        }
        loadPyodideAndRun();
      }, []);

      const pythonCode = `
import json
from collections import defaultdict

def clr_parser(grammar, input_string, step):
    output = []
    table_data = []
    parse_steps = []
    
    def add_output(text):
        output.append(text)
    
    def add_table_row(state, actions):
        table_data.append({"State": state, **actions})
    
    def add_parse_step(stack, input_buffer, action_goto, parsing_action):
        parse_steps.append({
            "stack": stack,
            "input_buffer": input_buffer,
            "action_goto": action_goto,
            "parsing_action": parsing_action
        })
    
    rules = []
    nonterminals = set()
    terminals = set()
    start_symbol = ""
    augmented_rules = []
    states = []
    state_count = 0
    goto_table = defaultdict(dict)
    action_table = defaultdict(dict)
    
    def parse_grammar():
        nonlocal rules, nonterminals, terminals, start_symbol
        lines = grammar.strip().split('\\n')
        for i, line in enumerate(lines, 1):
            line = line.strip()
            if not line:
                continue
            if "->" not in line:
                add_output(f"Line {i}: Invalid format! Please use '->' between LHS and RHS")
                return False, f"Invalid format on line {i}"
            lhs, rhs = map(str.strip, line.split("->"))
            if not lhs:
                add_output(f"Line {i}: Empty LHS not allowed")
                return False, f"Empty LHS on line {i}"
            nonterminals.add(lhs)
            productions = [prod.strip().split() for prod in rhs.split("|")]
            for prod in productions:
                if not prod:
                    add_output(f"Line {i}: Empty production not allowed")
                    return False, f"Empty production on line {i}"
                rule = {'lhs': lhs, 'rhs': prod, 'index': len(rules)}
                rules.append(rule)
                for symbol in prod:
                    if symbol not in nonterminals:
                        terminals.add(symbol)
        start_symbol = rules[0]['lhs'] if rules else ""
        if not start_symbol:
            add_output("No valid rules found")
            return False, "No valid rules"
        for rule in rules:
            for symbol in rule['rhs']:
                if any(r['lhs'] == symbol for r in rules):
                    nonterminals.add(symbol)
                    terminals.discard(symbol)
        if step == 'canonical':
            add_output("\\nNon-terminals detected: " + str(sorted(list(nonterminals))))
            add_output("Terminals detected: " + str(sorted(list(terminals))))
            add_output(f"Start symbol: {start_symbol}")
            add_output("\\nGrammar input:")
            for rule in rules:
                add_output(f"{rule['lhs']} -> {' '.join(rule['rhs'])}")
        return True, ""

    def grammar_augmentation():
        nonlocal augmented_rules, start_symbol
        augmented_start_symbol = start_symbol + "'"
        nonterminals.add(augmented_start_symbol)
        augmented_rules = [{"lhs": augmented_start_symbol, "rhs": [start_symbol], "index": 0}]
        for i, rule in enumerate(rules, 1):
            augmented_rules.append({"lhs": rule['lhs'], "rhs": rule['rhs'], 'index': i})
        if step == 'canonical':
            add_output("\\nAugmented Grammar:")
            for i, rule in enumerate(augmented_rules):
                add_output(f"{i}: {rule['lhs']} -> {' '.join(rule['rhs'])}")

    def first(symbol, visited=None):
        if visited is None:
            visited = set()
        result = set()
        if symbol in terminals or symbol == "#":
            result.add(symbol)
            return result
        if symbol in visited:
            return result
        visited.add(symbol)
        for rule in augmented_rules:
            if rule['lhs'] == symbol:
                rhs = rule['rhs']
                if not rhs:
                    result.add("#")
                else:
                    first_symbol = rhs[0]
                    sub_result = first(first_symbol, visited)
                    result.update(sub_result - {"#"})
                    if "#" in sub_result and len(rhs) > 1:
                        result.update(first(rhs[1], visited))
                    elif "#" in sub_result:
                        result.add("#")
        return result

    def closure(items):
        result = set(items)  # (lhs, rhs, dot, lookahead)
        added = True
        while added:
            added = False
            new_items = set()
            for lhs, rhs, dot, lookahead in result:
                if dot < len(rhs):
                    next_symbol = rhs[dot]
                    if next_symbol in nonterminals:
                        remaining = rhs[dot + 1:] if dot + 1 < len(rhs) else []
                        follow_symbols = first(' '.join(remaining)) if remaining else {lookahead}
                        if "#" in follow_symbols:
                            follow_symbols.remove("#")
                            follow_symbols = {lookahead} if lookahead in terminals or lookahead == "$" else follow_symbols
                        for rule in augmented_rules:
                            if rule['lhs'] == next_symbol:
                                for t in follow_symbols:
                                    new_item = (rule['lhs'], tuple(rule['rhs']), 0, t)
                                    if new_item not in result:
                                        new_items.add(new_item)
                                        added = True
            result.update(new_items)
        return frozenset(result)

    def goto_state(state, symbol):
        new_items = set()
        for lhs, rhs, dot, lookahead in state:
            if dot < len(rhs) and rhs[dot] == symbol:
                new_items.add((lhs, rhs, dot + 1, lookahead))
        return closure(new_items) if new_items else None

    def compute_canonical_sets():
        nonlocal states, state_count
        state_map = {}
        initial = closure({(start_symbol + "'", (start_symbol,), 0, "$")})
        states.append(initial)
        state_map[initial] = 0
        state_count = 1
        if step == 'canonical':
            add_output("\\nCalculated closure: I0")
            for lhs, rhs, dot, la in sorted(initial, key=lambda x: (x[0], x[1], x[2], x[3])):
                add_output(f"{lhs} -> {' '.join(['.' if i == dot else r for i, r in enumerate(rhs)])} , {la}")
        
        i = 0
        while i < state_count:
            state = states[i]
            symbols = set()
            for _, rhs, dot, _ in state:
                if dot < len(rhs):
                    symbols.add(rhs[dot])
            for symbol in sorted(symbols):
                next_state = goto_state(state, symbol)
                if next_state:
                    if next_state not in state_map:
                        state_map[next_state] = state_count
                        states.append(next_state)
                        state_count += 1
                        if step == 'canonical':
                            add_output(f"\\nCalculated closure: I{state_count-1}")
                            for lhs, rhs, dot, la in sorted(next_state, key=lambda x: (x[0], x[1], x[2], x[3])):
                                add_output(f"{lhs} -> {' '.join(['.' if i == dot else r for i, r in enumerate(rhs)])} , {la}")
                    goto_table[i][symbol] = state_map[next_state]
                    if step == 'canonical':
                        add_output(f"GOTO ( I{i} , {symbol} ) = I{state_map[next_state]}")
            i += 1
        
        if step == 'canonical':
            add_output("\\nStates Generated:")
            for i, state in enumerate(states):
                add_output(f"\\nState = I{i}")
                for lhs, rhs, dot, la in sorted(state, key=lambda x: (x[0], x[1], x[2], x[3])):
                    add_output(f"{lhs} -> {' '.join(['.' if i == dot else r for i, r in enumerate(rhs)])} , {la}")

    def create_parse_table():
        table_data.clear()
        action_table.clear()
        
        # Dynamically get terminals and non-terminals from the grammar
        all_terminals = sorted(list(terminals)) + ['$']  # Include end-of-string marker
        all_nonterminals = sorted(list(nonterminals - {start_symbol + "'"}))  # Exclude augmented start symbol
        
        # Create header row
        header = {"State": "State"}
        for t in all_terminals:
            header[t] = t
        for nt in all_nonterminals:
            header[nt] = nt
        add_table_row("State", header)
        
        # Compute actions and GOTO entries for each state
        for state_idx in range(state_count):
            actions = {t: "" for t in all_terminals}  # Initialize actions for terminals
            gotos = {nt: "" for nt in all_nonterminals}  # Initialize GOTO for non-terminals
            
            # Process each item in the current state
            for lhs, rhs, dot, lookahead in states[state_idx]:
                if dot < len(rhs):
                    # Shift action: If dot is before a symbol, look for next symbol
                    next_symbol = rhs[dot]
                    if next_symbol in terminals:
                        next_state = goto_table.get(state_idx, {}).get(next_symbol)
                        if next_state is not None:
                            current_action = actions.get(next_symbol, "")
                            if current_action:
                                # Only mark as conflict if actions differ in type or target
                                if (current_action.startswith('S') and not current_action.startswith(f'S{next_state}')) or \
                                   (current_action.startswith('R') and not current_action.startswith(f'R')) or \
                                   (current_action == 'Accept'):
                                    actions[next_symbol] = f"{current_action}/S{next_state} CONFLICT"
                                # If same shift state, keep the first one (no conflict)
                            else:
                                actions[next_symbol] = f"S{next_state}"
                    elif next_symbol in nonterminals:
                        # GOTO will be handled separately below
                        pass
                elif lhs == start_symbol + "'" and dot == len(rhs) and lookahead == "$":
                    # Accept action for the augmented start symbol with $
                    actions["$"] = "Accept"
                else:
                    # Reduce action: Find the rule and apply reduce for the lookahead
                    for rule in augmented_rules:
                        if rule['lhs'] == lhs and tuple(rule['rhs']) == rhs:
                            current_action = actions.get(lookahead, "")
                            if current_action:
                                # Check for true conflict (e.g., R1 vs S3 or R1 vs R2)
                                if (current_action.startswith('S') or current_action.startswith('Accept')) or \
                                   (current_action.startswith('R') and not current_action.startswith(f'R{rule["index"]}')):
                                    actions[lookahead] = f"{current_action}/R{rule['index']} CONFLICT"
                                # If same reduce rule, keep the first one (no conflict)
                            else:
                                actions[lookahead] = f"R{rule['index']}"
            
            # Add GOTO transitions from goto_table
            for nt in all_nonterminals:
                next_state = goto_table.get(state_idx, {}).get(nt)
                if next_state is not None:
                    gotos[nt] = str(next_state)
            
            # Combine actions and GOTOs into a row
            row = {"State": str(state_idx), **actions, **gotos}
            add_table_row(str(state_idx), row)
        
        if step == 'table':
            add_output("\\nCreated CLR parsing table based on canonical sets")

    def parse_input_string():
        tokens = input_string.strip().split() + ["$"]
        stack = [0]
        pointer = 0
        steps = []
        if step == 'parse':
            add_output("\\nParsing Steps:")
            add_output("--------------")
        
        while True:
            current_state = stack[-1]
            current_symbol = tokens[pointer] if pointer < len(tokens) else "$"
            
            # Get action from our dynamically created table
            action = ""
            if current_state < len(table_data) - 1:  # Skip header row
                row = table_data[current_state + 1]  # +1 because header is row 0
                action = row.get(current_symbol, "")
            
            stack_str = " ".join(str(x) for x in stack)
            input_str = " ".join(tokens[pointer:])
            
            # Determine the parsing action for the table
            parsing_action = ""
            if action.startswith("S"):
                parsing_action = f"Shift to state {action[1:].split(' ')[0]}"
            elif action.startswith("R"):
                rule_num = action[1:].split('/')[0]
                rule = augmented_rules[int(rule_num)]
                parsing_action = f"Reduce by rule {rule_num}: {rule['lhs']} -> {' '.join(rule['rhs'])}"
            elif action == "Accept":
                parsing_action = "Accept - Parsing completed successfully"
            
            # Add to both the text output and the table data
            if step == 'parse':
                add_output(f"Stack: {stack_str}, Input: {input_str}, Action: {action}")
                add_parse_step(stack_str, input_str, action, parsing_action)
            
            if not action:
                if step == 'parse':
                    add_output(f"\\nResult: Input string is REJECTED! (Error at state {current_state}, symbol {current_symbol})")
                    add_parse_step(stack_str, input_str, "ERROR", f"Error at state {current_state}, symbol {current_symbol}")
                return steps, False
            
            if action.startswith("S"):
                state_num = int(action.split("/")[0].replace("S", ""))  # Handle potential conflicts
                stack.extend([current_symbol, state_num])
                pointer += 1
            elif action.startswith("R"):
                rule_num = int(action.split("/")[0].replace("R", ""))  # Handle potential conflicts
                rule = augmented_rules[rule_num]
                rhs_len = len(rule['rhs'])
                if len(stack) < 2 * rhs_len:
                    if step == 'parse':
                        add_output(f"\\nResult: Input string is REJECTED! (Stack underflow for rule {rule_num})")
                        add_parse_step(stack_str, input_str, "ERROR", f"Stack underflow for rule {rule_num}")
                    return steps, False
                stack = stack[:-2 * rhs_len]
                prev_state = stack[-1]
                lhs = rule['lhs']
                
                # Get goto from our dynamically created table
                next_state = ""
                if prev_state < len(table_data) - 1:  # Skip header row
                    row = table_data[prev_state + 1]  # +1 because header is row 0
                    next_state = row.get(lhs, "")
                
                if not next_state:
                    if step == 'parse':
                        add_output(f"\\nResult: Input string is REJECTED! (Invalid GOTO from state {prev_state} on {lhs})")
                        add_parse_step(stack_str, input_str, "ERROR", f"Invalid GOTO from state {prev_state} on {lhs}")
                    return steps, False
                stack.extend([lhs, int(next_state)])
            elif action == "Accept":
                if step == 'parse':
                    add_output("\\nResult: Input string is ACCEPTED!")
                    add_parse_step(stack_str, input_str, "ACCEPT", "Input string accepted")
                return steps, True
            else:
                if step == 'parse':
                    add_output(f"\\nResult: Input string is REJECTED! (Invalid action {action} at state {current_state})")
                    add_parse_step(stack_str, input_str, "ERROR", f"Invalid action {action} at state {current_state}")
                return steps, False

    try:
        success, error = parse_grammar()
        if not success:
            return {"error": error, "output": "\\n".join(output), "table_data": table_data, "parse_steps": parse_steps}
        grammar_augmentation()
        compute_canonical_sets()
        if step in ['table', 'parse']:
            create_parse_table()
        if step == 'parse':
            steps, accepted = parse_input_string()
        return {"output": "\\n".join(output), "table_data": table_data, "parse_steps": parse_steps}
    except Exception as e:
        add_output(f"Error: {str(e)}")
        add_table_row("0", {"error": str(e)})
        return {"error": str(e), "output": "\\n".join(output), "table_data": table_data, "parse_steps": parse_steps}

def slr_parser(grammar, input_string, step):
    return {"error": "SLR parser not used for this example", "output": "SLR parser not used", "table_data": [], "parse_steps": []}

def lalr_parser(grammar, input_string, step):
    return {"error": "LALR parser not implemented", "output": "LALR parser not implemented", "table_data": [], "parse_steps": []}

def parse_grammar_wrapper(grammar, parser_type, input_string, step):
    try:
        if parser_type == 'SLR':
            result = slr_parser(grammar, input_string, step)
        elif parser_type == 'CLR':
            result = clr_parser(grammar, input_string, step)
        elif parser_type == 'LALR':
            result = lalr_parser(grammar, input_string, step)
        else:
            return {"error": "Invalid parser type", "output": "Invalid parser type", "table_data": [], "parse_steps": []}
        return result
    except Exception as e:
        return {"error": str(e), "output": f"Error: {str(e)}", "table_data": [{"State": "0", "error": str(e)}], "parse_steps": []}

def main(grammar, parser_type, input_string, step):
    result = parse_grammar_wrapper(grammar, parser_type, input_string, step)
    return json.dumps(result)
`;

      async function runParser(step) {
        if (!pyodide || isLoading) return;
        setIsLoading(true);
        try {
          const result = await pyodide.runPythonAsync(`
${pythonCode}
result = main("""${grammar.replace(/"/g, '\\"')}""", "${parserType}", "${inputString.replace(/"/g, '\\"')}", "${step}")
result
          `);
          const parsed = JSON.parse(result);
          if (parsed.error) {
            if (step === 'canonical') setCanonicalOutput(parsed.output || `Error: ${parsed.error}`);
            else if (step === 'table') {
              setTableData(parsed.table_data || [{ State: "0", error: parsed.error }]);
              setCanonicalOutput('');
              setParseOutput('');
              setParseTableData([]);
            } else if (step === 'parse') {
              setParseOutput(parsed.output || `Error: ${parsed.error}`);
              setParseTableData(parsed.parse_steps || []);
            }
            return;
          }
          if (step === 'canonical') {
            setCanonicalOutput(parsed.output);
            setTableData([]);
            setParseOutput('');
            setParseTableData([]);
          } else if (step === 'table') {
            setTableData(parsed.table_data || []);
            setCanonicalOutput('');
            setParseOutput('');
            setParseTableData([]);
          } else if (step === 'parse') {
            setParseOutput(parsed.output);
            setParseTableData(parsed.parse_steps || []);
            setCanonicalOutput('');
            setTableData([]);
          }
        } catch (error) {
          console.error("RunParser Error:", error);
          const errorMsg = `Error: ${error.message || 'Unexpected error occurred'}`;
          setError(errorMsg);
          if (step === 'canonical') setCanonicalOutput(errorMsg);
          else if (step === 'table') {
            setTableData([{ State: "0", error: errorMsg }]);
            setCanonicalOutput('');
            setParseOutput('');
            setParseTableData([]);
          } else if (step === 'parse') {
            setParseOutput(errorMsg);
            setParseTableData([]);
          }
        } finally {
          setIsLoading(false);
        }
      }

      return (
        <div className="min-h-screen bg-gradient-to-br from-blue-50 via-indigo-50 to-purple-50">
          <div className="container mx-auto p-6">
            {/* Header */}
            <div className="text-center mb-8 animate-fade-in">
              <h1 className="text-4xl font-bold bg-gradient-to-r from-blue-600 via-purple-600 to-indigo-600 bg-clip-text text-transparent mb-2">
                <i className="fas fa-code mr-3"></i>
                LR Parser Visualizer
              </h1>
              <p className="text-gray-600 text-lg">Visualize LR parsing algorithms with interactive step-by-step analysis</p>
            </div>

            {isLoading && (
              <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 backdrop-blur-sm">
                <div className="bg-white p-8 rounded-2xl shadow-2xl animate-pulse-slow">
                  <div className="flex items-center space-x-4">
                    <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
                    <div>
                      <p className="text-lg font-semibold text-gray-800">Processing...</p>
                      <p className="text-sm text-gray-600">Loading Pyodide and running parser</p>
                    </div>
                  </div>
                </div>
              </div>
            )}

            {error && (
              <div className="mb-6 p-4 bg-red-50 border-l-4 border-red-500 rounded-r-lg animate-slide-up">
                <div className="flex items-center">
                  <i className="fas fa-exclamation-triangle text-red-500 mr-3"></i>
                  <p className="text-red-700">{error}</p>
                </div>
              </div>
            )}
          
            {/* Input Section */}
            <div className="bg-white rounded-2xl shadow-lg p-6 mb-6 animate-slide-up">
              <h2 className="text-xl font-semibold text-gray-800 mb-4 flex items-center">
                <i className="fas fa-edit text-blue-600 mr-2"></i>
                Grammar Input
              </h2>
              <div className="mb-4">
                <label className="block mb-2 text-sm font-medium text-gray-700">
                  Grammar Rules (one rule per line, e.g., S â†’ C C):
                </label>
                <textarea
                  className="w-full p-4 border-2 border-gray-200 rounded-xl focus:border-blue-500 focus:ring-2 focus:ring-blue-200 transition-all duration-200 font-mono text-sm resize-none"
                  rows="5"
                  value={grammar}
                  onChange={(e) => setGrammar(e.target.value)}
                  placeholder="e.g., S -> C C&#10;C -> c C | d"
                />
              </div>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <label className="block mb-2 text-sm font-medium text-gray-700">
                    <i className="fas fa-cogs text-purple-600 mr-1"></i>
                    Parser Type:
                  </label>
                  <select
                    className="w-full p-3 border-2 border-gray-200 rounded-xl focus:border-purple-500 focus:ring-2 focus:ring-purple-200 transition-all duration-200 bg-white"
                    value={parserType}
                    onChange={(e) => setParserType(e.target.value)}
                  >
                    <option value="SLR">SLR (Simple LR)</option>
                    <option value="CLR">CLR (Canonical LR)</option>
                    <option value="LALR">LALR (Look-Ahead LR)</option>
                  </select>
                </div>
                <div>
                  <label className="block mb-2 text-sm font-medium text-gray-700">
                    <i className="fas fa-keyboard text-green-600 mr-1"></i>
                    Input String:
                  </label>
                  <input
                    className="w-full p-3 border-2 border-gray-200 rounded-xl focus:border-green-500 focus:ring-2 focus:ring-green-200 transition-all duration-200 font-mono"
                    value={inputString}
                    onChange={(e) => setInputString(e.target.value)}
                    placeholder="e.g., c c d d"
                  />
                </div>
              </div>
            </div>

            {/* Action Buttons */}
            <div className="bg-white rounded-2xl shadow-lg p-6 mb-6 animate-slide-up">
              <h2 className="text-xl font-semibold text-gray-800 mb-4 flex items-center">
                <i className="fas fa-play-circle text-indigo-600 mr-2"></i>
                Parser Actions
              </h2>
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                <button
                  className="bg-gradient-to-r from-blue-500 to-blue-600 text-white px-6 py-3 rounded-xl hover:from-blue-600 hover:to-blue-700 disabled:from-gray-400 disabled:to-gray-500 transition-all duration-200 transform hover:scale-105 disabled:scale-100 shadow-lg flex items-center justify-center space-x-2"
                  onClick={() => runParser('canonical')}
                  disabled={isLoading}
                >
                  <i className="fas fa-sitemap"></i>
                  <span>Generate Canonical Sets</span>
                </button>
                <button
                  className="bg-gradient-to-r from-purple-500 to-purple-600 text-white px-6 py-3 rounded-xl hover:from-purple-600 hover:to-purple-700 disabled:from-gray-400 disabled:to-gray-500 transition-all duration-200 transform hover:scale-105 disabled:scale-100 shadow-lg flex items-center justify-center space-x-2"
                  onClick={() => runParser('table')}
                  disabled={isLoading}
                >
                  <i className="fas fa-table"></i>
                  <span>Build Parsing Table</span>
                </button>
                <button
                  className="bg-gradient-to-r from-green-500 to-green-600 text-white px-6 py-3 rounded-xl hover:from-green-600 hover:to-green-700 disabled:from-gray-400 disabled:to-gray-500 transition-all duration-200 transform hover:scale-105 disabled:scale-100 shadow-lg flex items-center justify-center space-x-2"
                  onClick={() => runParser('parse')}
                  disabled={isLoading}
                >
                  <i className="fas fa-play"></i>
                  <span>Parse String</span>
                </button>
              </div>
            </div>

            {/* Results Section */}
            <div className="grid grid-cols-1 xl:grid-cols-2 gap-6">
              {/* Canonical Sets */}
              <div className="bg-white rounded-2xl shadow-lg p-6 animate-slide-up">
                <h2 className="text-xl font-semibold mb-4 flex items-center text-gray-800">
                  <i className="fas fa-project-diagram text-blue-600 mr-2"></i>
                  Canonical Sets
                </h2>
                {canonicalOutput ? (
                  <div className="bg-gray-50 rounded-xl p-4 max-h-96 overflow-y-auto border">
                    <pre className="whitespace-pre-wrap text-sm font-mono text-gray-700 leading-relaxed">
                      {canonicalOutput}
                    </pre>
                  </div>
                ) : (
                  <div className="bg-gray-50 rounded-xl p-8 text-center border-2 border-dashed border-gray-300">
                    <i className="fas fa-info-circle text-gray-400 text-2xl mb-2"></i>
                    <p className="text-gray-500">Click "Generate Canonical Sets" to see the results</p>
                  </div>
                )}
              </div>

              {/* Parsing Table */}
              <div className="bg-white rounded-2xl shadow-lg p-6 animate-slide-up">
                <h2 className="text-xl font-semibold mb-4 flex items-center text-gray-800">
                  <i className="fas fa-table text-purple-600 mr-2"></i>
                  Parsing Table
                </h2>
                {tableData.length > 0 ? (
                  <div className="bg-gray-50 rounded-xl p-4 overflow-x-auto border">
                    <table className="min-w-full border-collapse">
                      <thead>
                        <tr className="bg-gradient-to-r from-gray-100 to-gray-200">
                          {Object.keys(tableData[0]).map((key) => (
                            <th 
                              key={key} 
                              className="border border-gray-300 px-3 py-2 text-left text-sm font-semibold text-gray-700 first:rounded-tl-lg last:rounded-tr-lg"
                            >
                              {key}
                            </th>
                          ))}
                        </tr>
                      </thead>
                      <tbody className="bg-white">
                        {tableData.slice(1).map((row, i) => (
                          <tr key={i} className="hover:bg-gray-50 transition-colors duration-150">
                            {Object.entries(row).map(([key, value]) => (
                              <td 
                                key={key} 
                                className={`border border-gray-300 px-3 py-2 text-sm ${
                                  typeof value === 'string' && value.startsWith('S') ? 'text-blue-600 font-semibold bg-blue-50' : 
                                  typeof value === 'string' && value.startsWith('R') ? 'text-red-600 font-semibold bg-red-50' : 
                                  value === 'Accept' ? 'text-green-600 font-bold bg-green-50' : 
                                  value && value.includes('CONFLICT') ? 'text-orange-600 font-semibold bg-orange-50' : 'text-gray-700'
                                }`}
                              >
                                {value || '-'}
                              </td>
                            ))}
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                ) : (
                  <div className="bg-gray-50 rounded-xl p-8 text-center border-2 border-dashed border-gray-300">
                    <i className="fas fa-table text-gray-400 text-2xl mb-2"></i>
                    <p className="text-gray-500">Click "Build Parsing Table" to see the results</p>
                  </div>
                )}
                {tableData[0]?.error && (
                  <div className="mt-4 p-4 bg-red-50 border-l-4 border-red-500 rounded-r-lg">
                    <p className="text-red-700 flex items-center">
                      <i className="fas fa-exclamation-triangle mr-2"></i>
                      {tableData[0].error}
                    </p>
                  </div>
                )}
              </div>
            </div>

            {/* Parsing Steps */}
            <div className="mt-6 bg-white rounded-2xl shadow-lg p-6 animate-slide-up">
              <h2 className="text-xl font-semibold mb-4 flex items-center text-gray-800">
                <i className="fas fa-list-ol text-green-600 mr-2"></i>
                Parsing Steps
              </h2>
              {parseOutput ? (
                <div>
                  <div className="bg-gray-50 rounded-xl p-4 max-h-64 overflow-y-auto border mb-4">
                    <pre className="whitespace-pre-wrap text-sm font-mono text-gray-700 leading-relaxed">
                      {parseOutput}
                    </pre>
                  </div>
                  
                  {parseTableData.length > 0 && (
                    <div className="bg-gray-50 rounded-xl p-4 overflow-x-auto border">
                      <table className="min-w-full border-collapse">
                        <thead>
                          <tr className="bg-gradient-to-r from-gray-100 to-gray-200">
                            <th className="border border-gray-300 px-4 py-3 text-left text-sm font-semibold text-gray-700 rounded-tl-lg">
                              <i className="fas fa-layer-group mr-1"></i>Stack
                            </th>
                            <th className="border border-gray-300 px-4 py-3 text-left text-sm font-semibold text-gray-700">
                              <i className="fas fa-keyboard mr-1"></i>Input Buffer
                            </th>
                            <th className="border border-gray-300 px-4 py-3 text-left text-sm font-semibold text-gray-700">
                              <i className="fas fa-arrow-right mr-1"></i>Action/Goto
                            </th>
                            <th className="border border-gray-300 px-4 py-3 text-left text-sm font-semibold text-gray-700 rounded-tr-lg">
                              <i className="fas fa-cog mr-1"></i>Parsing Action
                            </th>
                          </tr>
                        </thead>
                        <tbody className="bg-white">
                          {parseTableData.map((step, i) => (
                            <tr key={i} className="hover:bg-gray-50 transition-colors duration-150">
                              <td className="border border-gray-300 px-4 py-3 font-mono text-sm text-gray-700">{step.stack}</td>
                              <td className="border border-gray-300 px-4 py-3 font-mono text-sm text-gray-700">{step.input_buffer}</td>
                              <td className={`border border-gray-300 px-4 py-3 font-mono text-sm font-semibold ${
                                step.action_goto.startsWith('S') ? 'text-blue-600 bg-blue-50' : 
                                step.action_goto.startsWith('R') ? 'text-red-600 bg-red-50' : 
                                step.action_goto === 'ACCEPT' ? 'text-green-600 bg-green-50' : 
                                step.action_goto.includes('ERROR') ? 'text-red-600 bg-red-100' : 'text-gray-700'
                              }`}>
                                {step.action_goto}
                              </td>
                              <td className="border border-gray-300 px-4 py-3 text-sm text-gray-700">{step.parsing_action}</td>
                            </tr>
                          ))}
                        </tbody>
                      </table>
                    </div>
                  )}
                </div>
              ) : (
                <div className="bg-gray-50 rounded-xl p-8 text-center border-2 border-dashed border-gray-300">
                  <i className="fas fa-play-circle text-gray-400 text-2xl mb-2"></i>
                  <p className="text-gray-500">Click "Parse String" to see the step-by-step parsing process</p>
                </div>
              )}
            </div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>